#!/usr/bin/env bash

###########################################
# This is the project's developer toolkit #
# It was generated by                     #
# generator-dockerize                     #
#
# if you find an issue with this script
# make a pull-request on
# https://github.com/atomantic/generator-dockerize
#
# @author Adam Eivy                       #
# @maintainer Joseph Sturtevant           #
# DockerDev: 1.10.0                       #
###########################################


# project specific config
source ./dev.config

# docker-compose will strip underscores from the app name to tack on _web
APP_NAME_LOCAL=${APP_NAME//_/}"_web"
REMOTE_NAME="$DOCKER_REPO/$APP_ORG/$APP_NAME"
RSYNC_URL="http://repo.tinycorelinux.net/"
VPN_KEY=`echo "show State:/Network/Service/com.cisco.anyconnect/DNS" | scutil`
HOST_DOCKER_DAEMON_PORT=2376

###
# echo helper functions
###
# Colors
ESC_SEQ="\x1b["
COL_RESET=$ESC_SEQ"39;49;00m"
COL_RED=$ESC_SEQ"31;01m"
COL_GREEN=$ESC_SEQ"32;01m"
COL_YELLOW=$ESC_SEQ"33;01m"

function ok() {
  echo -e "$COL_GREEN[ok]$COL_RESET "$1
}
function bot() {
  echo; echo -e "$COL_GREEN\[._.]/$COL_RESET - "$1
}
function running() {
  echo; echo -en " ⇒ "$1"..."
}
function action() {
  echo -e "$COL_YELLOW[action]$COL_RESET"; echo -en " ⇒ "$1"..."
}
function warn() {
  echo -e "$COL_YELLOW[warning]$COL_RESET "$1
}
function error() {
  echo -e "$COL_RED[error]$COL_RESET "$1
}

###
# some bash install helpers
###
function require_cask() {
    running "which $1"
    which $1 > /dev/null 2>&1 | true
    if [[ ${PIPESTATUS[0]} != 0 ]]; then
        brew cask list $1 > /dev/null 2>&1 | true
        if [[ ${PIPESTATUS[0]} != 0 ]]; then
            action "brew cask install $1 $2"
            brew cask install $1
            if [[ $? != 0 ]]; then
                error "failed to install $1! aborting..."
                exit -1
            fi
        fi
    fi
    ok
}

function require_tap() {
    running "checking brew tap $1"
    brew tap | grep $1
    if [[ $? != 0 ]]; then
        action "brew tap $1"
        brew tap $1
        if [[ $? != 0 ]]; then
            error "failed to add brew tap $1! aborting..."
            exit -1
        fi
    fi
    ok
}
function require_brew() {
    running "which $1"
    which $1 > /dev/null 2>&1 | true
    if [[ ${PIPESTATUS[0]} != 0 ]]; then
        action "brew install $1 $2"
        brew install $1 $2
        if [[ $? != 0 ]]; then
            error "failed to install $1! aborting..."
            exit -1
        fi
    fi
    ok
}


function install_homebrew() {
    running "checking homebrew"
    brew_bin=$(which brew) 2>&1 > /dev/null
    if [[ $? != 0 ]]; then
        action "installing homebrew"
        ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
        if [[ $? != 0 ]]; then
            error "unable to install homebrew, script $0 abort!"
            exit -1
        fi
    fi
    ok
}

function install_brewcask() {
    running "checking brew-cask"
    output=$(brew tap | grep cask)
    if [[ $? != 0 ]]; then
        action "installing brew-cask"
        require_brew caskroom/cask/brew-cask
    fi
    ok
}


function checkInstall() {
  running "checking install of $1"
  case "$1" in
    *)
        which $1
        ;;
  esac
  if [[ $? != 0 ]]; then
    warn "$1 is not installed";
    return 1;
  fi
  ok
  return 0;
}

###
# Docker helpers
###
function dockerStart(){

    # still working on VPN fix
    #ensurePort $APP_PORT_EXTERNAL

    running "starting rsync into $VM_NAME"
    startRsync
    ok

    APPURL=""
    if [[ "${VPN_KEY}" == *"No such key"* ]]; then
      APPURL=http://$(docker-machine ip $VM_NAME 2>/dev/null):$APP_PORT_EXTERNAL
    else
      APPURL=http://localhost:$APP_PORT_EXTERNAL
    fi
    # instead of loading the VBox IP, we are routing localhost:$APP_PORT_EXTERNAL to VM
    # APPURL=http://localhost:$APP_PORT_EXTERNAL

    running "starting via 'docker-compose up'"
    docker-compose up &

    docker images | grep $APP_NAME_LOCAL > /dev/null 2>&1

    if [[ $? != 0 ]]; then
      # give it time to create and launch the image
      bot "giving docker-compose time to create the image..."
      sleep $VM_CREATE_TIME
    fi

    # load in browser
    bot "OK, the app is booting up, we need to wait just a bit before trying to load it..."
    for i in $(seq $APP_BOOT_TIME 1);do
      bot "$i...";
    sleep 1;
    done

    if [[ $1 != "background" ]]; then

      bot "Launching: $APPURL"
      bot "If the app doesn't work, you can debug it by running the following:\n\$(docker-machine env $VM_NAME > /dev/null);\ndocker exec -i -t \$(docker ps | grep $APP_NAME_LOCAL | awk '{print $1;}') bash"
      # open $APPURL:$APP_PORT_EXTERNAL
      open $APPURL

    fi
}

# setup port forwarding localhost:$APP_PORT_EXTERNAL -> VirtualBox
function ensurePort(){
  running "ensuring port forwarding: "$APP_NAME_LOCAL"_"$1
  VBoxManage showvminfo $VM_NAME | grep $APP_NAME_LOCAL"_"$1 > /dev/null 2>&1
  if [ $? != 0 ]; then
    bot "adding port forwarding for $APP_NAME_LOCAL to $1"
    VBoxManage controlvm $VM_NAME natpf1 $APP_NAME_LOCAL"_"$1,tcp,,$1,,$1
  fi
  ok
}

function vpnEnv(){
  echo "=====Add these to your environment to access Docker directly through VPN====="
  echo "export DOCKER_TLS_VERIFY='1'"
  echo "export DOCKER_HOST='tcp://localhost:${HOST_DOCKER_DAEMON_PORT}'"
  echo "export DOCKER_CERT_PATH='${HOME}/.docker/machine/machines/${VM_NAME}'"
  echo "export DOCKER_MACHINE_NAME='${VM_NAME}'"
}

function dockerVPN(){
  #Author: Onejli
  #Source: https://github.com/onejli/docker-vpn-helper
  #Modified by: Joseph Sturtevant

  #Modified code from source to have it work in dev script

  GUEST_STATUS=`docker-machine status ${VM_NAME} 2>&1`
  set -e
  if [ "${GUEST_STATUS}" ==  "unable to load host: Error: Host does not exist: ${VM_NAME}" ]; then
      #Create a new Docker host if it doesn't already exist
      if [[ "${VPN_KEY}" != *"No such key"* ]]; then
          printf "\nPlease disconnect from the VPN before creating VM,\nthen reconnect to VPN and run command again"
          exit 1
      fi

      VBOX_PROCS=`pgrep -f "VirtualBox.app" || exit 0`
      if [ -n "${VBOX_PROCS}" ]; then
          echo "Please stop all VirtualBox.app processes"
          echo ${VBOX_PROCS}
          exit 2
      fi

      #TODO Always reload these if the routing table doesn't have vboxnet entries?  Either we've:
      #1. Disconnected from the VPN and the VPN client has removed the routes without restoring them
      #       -> The VirtualBox kernel modules are unhappy and can't re-add the routes
      #          We *must* restart the kernel modules to recover from this situation
      #2. Started on a fresh host that hasn't connected to VPN...yet
      #       -> Starting any VirtualBox VM should create the routes
      #          Restarting the kernel modules isn't needed, but doesn't cost us anything (other than time)
      #3. Started on a host where VirtualBox isn't configured with *any* host-only network adapters
      #       -> No routes are needed or will ever be added
      #          Restarting the kernel modules isn't needed, but doesn't cost us anything (other than time)

      #TODO Expose this as a standalone command (with the pgrep sanity check)
      echo "=====Restarting VirtualBox kernel modules====="
      #We only really need to restart the VirtualBox network kernel modules, but it's easier to restart everything
      sudo /Library/Application\ Support/VirtualBox/LaunchDaemons/VirtualBoxStartup.sh restart

      echo "=====[${VM_NAME}] Creating Docker host====="
      docker-machine create -d virtualbox ${VM_NAME}

  elif [ "${GUEST_STATUS}" == "Stopped" ]; then
      #Start the Docker host if it isn't already running
      echo "=====[${VM_NAME}] Starting Docker host====="
      docker-machine start ${VM_NAME}
  fi

  #Add a port forwarding rule if it doesn't already exist
  GUEST_DOCKER_DAEMON_PORT=`VBoxManage showvminfo ${VM_NAME} | grep "guest port = 2376" | sed -e "s/^.*host port = \([0-9]*\),.*/\1/"`
  if [ -z "${GUEST_DOCKER_DAEMON_PORT}" ]; then
      #Work around the Cisco VPN client bogarting the routing table by using port forwarding for the Docker daemon in the VM
      echo "=====[${VM_NAME}] Inserting Docker daemon port forwarding rule====="
      #To allow physical device to talk to VM
      VBoxManage controlvm ${VM_NAME} natpf1 dockerdaemon,tcp,127.0.0.1,${HOST_DOCKER_DAEMON_PORT},,2376
      #To access app container
      VBoxManage controlvm ${VM_NAME} natpf1 $APP_NAME_LOCAL,tcp,127.0.0.1,$APP_PORT_EXTERNAL,,$APP_PORT_EXTERNAL
  fi

  #The Docker daemon and client are protected by mutual auth, but docker-machine creates a cert for the Docker daemon that
  #only binds to the IP of VirtualBox's host-only adapter (that's unroutable because of the Cisco VPN client).  Let's fix
  #this by creating a cert that binds to localhost, 127.0.0.1, *and* the IP of the Virtualbox host-only adapter so the Docker
  #daemon can service requests from the forwarded port *and* the host-only adapter.
  DOCKER_MACHINES_HOME=${HOME}/.docker/machine/machines
  DOCKER_CERTS_HOME=${HOME}/.docker/machine/certs
  SERVER_PEM_LOCATION=/var/lib/boot2docker/server.pem
  SERVER_PEM=`docker-machine ssh ${VM_NAME} "openssl x509 -noout -text -in ${SERVER_PEM_LOCATION}"`
  #TODO Check the cert that the daemon is serving rather than the cert on disk?
  #     openssl s_client -connect localhost:2376 -tls1 -CAfile ${DOCKER_CERTS_HOME}/ca.pem -cert ${DOCKER_CERTS_HOME}/cert.pem -key ${DOCKER_CERTS_HOME}/key.pem 2>/dev/null </dev/null | openssl x509 -outform PEM

  #TODO Regenerate the cert if it's going to expire in the next day?
  #     openssl x509 -checkend 86400 -noout -in ${SERVER_PEM_LOCATION}

  #TODO Expose manual regeneration of the cert as a standalone command
  if [[ ${SERVER_PEM} != *"CN=localhost"* && ${SERVER_PEM} != *"IP:127.0.0.1"* ]]; then
      #(Re)create the cert if it's missing localhost or 127.0.0.1
      echo "=====[${VM_NAME}] Creating a new Docker daemon certificate====="
      #Let's be good citizens.  Preserve the original cert and re-use the private key.
      mv ${DOCKER_MACHINES_HOME}/${VM_NAME}/server.pem ${DOCKER_MACHINES_HOME}/${VM_NAME}/server.pem.bak

      #Create a new cert for the Docker daemon and sign it
      openssl req -subj "/CN=localhost" -sha256 -new -key ${DOCKER_MACHINES_HOME}/${VM_NAME}/server-key.pem -out ${DOCKER_MACHINES_HOME}/${VM_NAME}/server.csr
      echo "subjectAltName = IP:$(docker-machine ip ${VM_NAME}),IP:127.0.0.1" > ${DOCKER_MACHINES_HOME}/${VM_NAME}/extfile.cnf
      openssl x509 -req -days 365 -sha256 -in ${DOCKER_MACHINES_HOME}/${VM_NAME}/server.csr -CA ${DOCKER_CERTS_HOME}/ca.pem -CAkey ${DOCKER_CERTS_HOME}/ca-key.pem -set_serial 0x6f6e656a6c69 -out ${DOCKER_MACHINES_HOME}/${VM_NAME}/server.pem -extfile ${DOCKER_MACHINES_HOME}/${VM_NAME}/extfile.cnf

      #Deploy the new cert to the Docker host and restart the Docker daemon to pick up the change
      echo "=====[${VM_NAME}] Deploying Certificate to Docker host====="
      NEW_SERVER_PEM=`cat ${DOCKER_MACHINES_HOME}/${VM_NAME}/server.pem`
      docker-machine ssh ${VM_NAME} "echo -e '${NEW_SERVER_PEM}' | sudo tee ${SERVER_PEM_LOCATION}"
      echo "=====[${VM_NAME}] Restarting Docker daemon====="
      docker-machine ssh ${VM_NAME} "sudo /etc/init.d/docker restart"
      vpnEnv
      #Give docker time to restart
      sleep 1;
  fi
}

function dockerStop(){
  running "stopping rsync"
  stopRsync
  ok
  running "stopping docker containers"
  docker-compose stop > /dev/null 2>&1
  ok
}

function shellinit(){
    running "shellinit"
    # make sure docker port routing is in place (need this if we are on cisco vpn on yosemite)
    # https://github.com/boot2docker/boot2docker/issues/392#issuecomment-66694197
    # still working on VPN fix... this isn't working with docker-machine
    # maybe a fix in here somewhere: https://github.com/docker/machine/issues/1031
    #ensurePort 2376
    #export DOCKER_HOST=tcp://127.0.0.1:2376;
    if [[ "${VPN_KEY}" == *"No such key"* ]]; then
      #We're not connected to VPN, set environment variables as normal
      eval "$(docker-machine env $VM_NAME)"
    else
      #We are connected to VPN. Run helper script and set new environment variables
      #Only difference between this and $(docker-machine env $VM_NAME) is the DOCKER_HOST
      dockerVPN
      export DOCKER_TLS_VERIFY="1"
      export DOCKER_HOST="tcp://localhost:2376"
      export DOCKER_CERT_PATH="$HOME/.docker/machine/machines/$VM_NAME"
      export DOCKER_MACHINE_NAME="$VM_NAME"
    fi
    ok
}

# ensure that docker is running and mapped properly to the VM
function ensureDocker() {

    running "ensuring $VM_NAME vm is running"

    docker-machine ls | grep $VM_NAME > /dev/null 2>&1
    if [[ $? != 0 ]]; then
      # vm doesn't exist
      if [[ "${VPN_KEY}" == *"No such key"* ]]; then
        action "$VM_NAME vm does not exist. Creating it"

        docker-machine create -d virtualbox $VM_NAME
      else
        printf "\n"
        warn "**VPN Connection Detected**\nPlease disconnect from VPN and run ./dev vpn_setup before reconnecting"
        exit 1
      fi
    fi
    docker-machine ls | grep $VM_NAME | grep Running > /dev/null 2>&1
    if [[ $? != 0 ]]; then
      bot "starting the vm"
      docker-machine start $VM_NAME
    fi
    ok

    shellinit
    set +e
    docker ps > /dev/null 2>&1;
    if [[ $? != 0 ]]; then
      defaultError
    else
     return 1;
    fi
}

function startRsync(){
  # only do one
  stopRsync
  dir=$(pwd);
  docker-rsync -watch=true -src="$dir/$APP_LOC" -dst="/Users/$(whoami)/rsync$dir/$APP_LOC" $VM_NAME &
  if [[ $? != 0 ]]; then
    bot "Fixing URL path in $VM_NAME"
    if [[ "$(docker-machine ssh $VM_NAME 'cat /opt/tcemirror')" != "$RSYNC_URL" ]]; then
      docker-machine ssh $VM_NAME "echo '$RSYNC_URL' > /opt/tcemirror"
    fi
    bot "Trying docker-rsync again"
    docker-rsync -src="$dir/$APP_LOC" -dst="/Users/$(whoami)/rsync$dir/$APP_LOC" $VM_NAME &
    if [[ $? != 0 ]]; then
      warn "Something went wrong with loading rsync"
    else
      ok
    fi
  fi
}

function stopRsync(){
  #Check if rsync is already running
  if [[ $(ps ax | grep rsync | grep $(pwd) | grep -v grep | awk '{print $1}') == "" ]]; then
    return 0;
  fi
  #Else kill any processes where rsync is running
  kill -9 `ps ax | grep rsync | grep $(pwd) | grep -v grep | awk '{print $1}'`
  #Returning 1 stops script when on VPN
  return 1;
}

function ensureMount(){
    # create an rsync directory in my home directory
    # so we don't use up all the space on the virtual machine
    # root path
    # (/Users is already mounted as a share by VirtualBox)
    if [ ! -d "/Users/$(whoami)/rsync" ]; then
      mkdir -p /Users/$(whoami)/rsync
    fi
    # we will then use docker-rsync to rsync into this directory
}
# OS_VERSION=$(sw_vers -productVersion);
# OS_MAJOR=`echo $OS_VERSION | cut -d. -f1`
# OS_MINOR=`echo $OS_VERSION | cut -d. -f2`
# OS_PATCH=`echo $OS_VERSION | cut -d. -f3`
function defaultError()
{
    error "sorry, we have not yet figured out an automated solution to this problem. Please investigate and pull-request to https://github.com/atomantic/generator-dockerize"
    exit 1;
}

#Allows VM to connect to $DOCKER_REPO insecure registry
function insecureRegistry()
{
    ensureDocker
    docker-machine ssh $VM_NAME "grep 'insecure-registry' /var/lib/boot2docker/profile" > /dev/null 2>&1
    if [[ $? != 0 ]]; then
      docker-machine ssh $VM_NAME "echo EXTRA_ARGS=\'--insecure-registry $DOCKER_REPO\' | sudo tee -a /var/lib/boot2docker/profile"
      docker-machine ssh $VM_NAME "sudo /etc/init.d/docker restart"
      sleep 1
      docker-machine restart $VM_NAME
    fi
    ok
}

case "$1" in
    clean)
        # purges the docker images relating to this app
        ensureDocker
        docker ps -a | grep $APP_NAME_LOCAL
        if [[ $? == 0 ]]; then
          docker rm -f $(docker ps -a | grep $APP_NAME_LOCAL | awk '{print $1;}')
        fi
        docker images | grep $APP_NAME_LOCAL > /dev/null 2>&1
        if [ $? == 0 ]; then
          docker rmi -f $APP_NAME_LOCAL
        fi
        ok
        ;;
    free)
        ensureDocker
        running "removing all stopped containers"
        docker rm $(docker ps -a -q) > /dev/null 2>&1
        ok
        running "removing all untagged images (cruft)"
        docker rmi $(docker images -q --filter "dangling=true") > /dev/null 2>&1
        ok
        ;;
    init)
        bot "Hi, I'm going to setup/update your environment and startup the app using Docker"

        bot "working on "$APP_ORG/$APP_NAME:$APP_PORT_EXTERNAL;

        need_tools=0
        install_homebrew
        require_tap synack/docker
        require_brew docker-rsync

        needed_software=( "docker" "docker-compose" "docker-machine" "vboxmanage" )
        for sft in "${needed_software[@]}"; do
          checkInstall $sft
          if [ $? != 0 ]; then
            need_tools=1
          fi
        done

        if [ $need_tools == 1 ]; then
          install_brewcask
          require_cask dockertoolbox
          ok
        fi

        # setup docker-compose.yml
        me=$(whoami)
        dir=$(pwd)
        cat docker-compose.tmpl | sed "s~_SYNCDIR_~/Users/$me/rsync$dir/$APP_LOC~" > docker-compose.yml
        # run dev.init instructions (install base npm modules, etc)
        source ./dev.init.sh

        ensureMount

        echo "launching quickstart shell. once this is done"
        echo "cd "$(pwd)
        echo "./dev start"

        for i in $(seq 5 1);do
          bot "$i...";
        sleep 1;
        done

        bash --login '/Applications/Docker/Docker Quickstart Terminal.app/Contents/Resources/Scripts/start.sh'
        ;;
    insecure_registry)
        insecureRegistry
        ;;
    purge)
        bot "Starting Purge. ensuring rsync isn't running..."
        stopRsync
        ok
        bot "dockerized-vm machine"
        read -r -p "Shall I destroy this machine (with all docker images/containers in it)? [Y|n]" response
        if [[ $response =~ ^(no|n|N) ]];then
          bot "skipping..."
        else
          action "destroying the dockerized-vm machine"
          docker-machine kill $VM_NAME;
          docker-machine rm $VM_NAME;
          ok
        fi
        bot "VirtualBox Software"
        read -r -p "Uninstall VirtualBox? [y|N]" response
        if [[ $response =~ ^(y|Y|yes) ]];then
          action "killing virtualbox"
          pkill VBoxXPCOMIPCD
          pkill VBoxSVC
          pkill VBoxNetDHCP
          pkill VBoxHeadless
          ok
          bot "uninstall virtualbox"
          brew cask uninstall virtualbox
          ok
        else
          bot "skipping..."
        fi
        bot "Docker Software"
        read -r -p "Uninstall Docker Components? [y|N]" response
        if [[ $response =~ ^(y|Y|yes) ]];then
          action "uninstalling docker, docker-machine and docker-compose"
          brew uninstall docker docker-machine docker-compose
          ok
        else
          bot "skipping..."
        fi
        bot "run 'dev init' again"
        ;;
    rebuild)
        docker-compose build
        dockerStart $1
        ;;
    restart)
        ensureDocker
        dockerStop
        dockerStart $1
        ;;
    shell)
        ensureDocker
        if [ -z $1 ]; then
          # run any version deployed to docker hub
          bot "checking $REMOTE_NAME for version tag $2"
          docker run -t $REMOTE_NAME:$2
          docker exec -i -t $(docker ps | grep $REMOTE_NAME:$2 | awk '{print $1;}') bash
          exit $?;
        fi
        instance=$(docker ps | grep $APP_NAME_LOCAL | awk '{print $1;}')
        if [ -z "$instance" ]; then
          docker run -i -t $APP_NAME_LOCAL bash
        else
          docker exec -i -t $instance bash
        fi
        ;;
    start)
        ensureDocker
        dockerStart $1
        ;;
    stop)
        ensureDocker
        dockerStop
        ;;
    test)
        ensureDocker
        build_scripts/test.sh 0.1.0 $APP_NAME_LOCAL $APP_PORT_EXTERNAL $APP_PORT_INTERNAL $VM_NAME
        ok "done"
        ;;
    update)
        bot "updating the dev toolkit"
        curl -o dev.latest https://raw.githubusercontent.com/atomantic/generator-dockerize/master/app/templates/dev
        ok "fetched latest"
        oldversion=$(grep "^# DockerDev:" dev | sed 's/[^0-9.]//g');
        newversion=$(grep "^# DockerDev:" dev.latest | sed 's/[^0-9.]//g');

        if [ "$oldversion" != "$newversion" ]; then
          bot "Update found! old: $oldversion -> new: $newversion"
          cp dev.latest dev
        fi
        rm dev.latest
        ok "you have the latest version: $newversion"
        ;;
    vpn)
        bot "Fixing route table after Cisco VPN disconnect"
        read -r -p "Did you disconnect VPN? [Y|n]" response
        if [[ $response =~ ^(no|n|N) ]];then
          bot "well do that and re-run this..."
          exit 2;
        fi
        ok
        VBOXNET=$(VBoxManage showvminfo $VM_NAME --machinereadable | grep hostonlyadapter | cut -d '"' -f 2)

        if [ -z "$VBOXNET" ]; then
          error "No vboxnet interface found for VM $VM_NAME"
          exit -1;
        fi
        ip_address=$(docker-machine ip $VM_NAME)
        ip_sub=$(echo $ip_address | sed 's/.[^\.]*$//g')
        bot "Requires sudo:"
        sudo route -n delete -net $ip_sub
        sudo route -n add -net $ip_sub.0/24 -interface $VBOXNET
        ok
        ;;
    vpn_env)
        vpnEnv
        ;;
    vpn_setup)
        #Creating the docker-machine VM while on the VPN seems to hang.
        #Creating the VM before connecting to VPN seems to address issue.
        dockerVPN
        ;;
    *)
        bot "Hi, I can do a few helpful development tricks.\n"
        echo -e "Run each as an argument to this script (e.g. './dev init'):\n"
        echo "clean - remove locally built docker containers and images relating to this app"
        echo "free - remove clutter (stopped containers and untagged images)"
        echo "init - initialize your development environment (installing and running the app)"
        echo "insecure_registry - sets up Docker to connect to an insecure registry"
        echo "purge - uninstall virtualbox, destroy the dockerized-vm machine and uninstall all docker software"
        echo "rebuild - rebuild the service"
        echo "restart - restart the service"
        echo "shell {version} - get a bash shell on the current running system or on a version from the hub"
        echo "start - start the service"
        echo "stop - stop the service"
        echo "test - test the service by running a docker image and pointing tests at the image"
        echo "tool - choose between docker-machine or vagrant"
        echo "update - update the dev tool with the latest automation scripts"
        echo "vpn - fix routing table after disconnecting from Cisco Anyconnect VPN client"
        echo "vpn_env - display environment variables you need to export to access Docker through VPN"
        echo "vpn_setup - use while disconnected from VPN to setup Docker for VPN"
        ;;
esac
