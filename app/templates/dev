#!/usr/bin/env bash

###########################################
# This is the project's developer toolkit #
# It was generated by                     #
# generator-dockerize                     #
#
# if you find an issue with this script
# make a pull-request on
# https://github.com/atomantic/generator-dockerize
#
# @author Adam Eivy                       #
# @maintainer Joseph Sturtevant           #
# DockerDev: 2.1.2                        #
###########################################


# project specific config
source ./dev.config

# docker-compose will strip underscores from the app name to tack on _web
APP_NAME_LOCAL=${APP_NAME//_/}"_web"
REMOTE_NAME="$DOCKER_REPO/$APP_ORG/$APP_NAME"
RSYNC_URL="http://repo.tinycorelinux.net/"
HOST_DOCKER_DAEMON_PORT=2376

###
# echo helper functions
###
# Colors
ESC_SEQ="\x1b["
COL_RESET=$ESC_SEQ"39;49;00m"
COL_RED=$ESC_SEQ"31;01m"
COL_GREEN=$ESC_SEQ"32;01m"
COL_YELLOW=$ESC_SEQ"33;01m"

function ok() {
  echo -e "$COL_GREEN[ok]$COL_RESET "$1
}
function bot() {
  echo; echo -e "$COL_GREEN\[._.]/$COL_RESET - "$1
}
function running() {
  echo; echo -en " ⇒ "$1"..."
}
function action() {
  echo -e "$COL_YELLOW[action]$COL_RESET"; echo -en " ⇒ "$1"..."
}
function warn() {
  echo -e "$COL_YELLOW[warning]$COL_RESET "$1
}
function error() {
  echo -e "$COL_RED[error]$COL_RESET "$1
}

###
# some bash install helpers
###
function require_cask() {
    running "which $1"
    which $1 > /dev/null 2>&1 | true
    if [[ ${PIPESTATUS[0]} != 0 ]]; then
        brew cask list $1 > /dev/null 2>&1 | true
        if [[ ${PIPESTATUS[0]} != 0 ]]; then
            action "brew cask install $1 $2"
            brew cask install $1
            if [[ $? != 0 ]]; then
                error "failed to install $1! aborting..."
                exit -1
            fi
        fi
    fi
    ok
}

function require_tap() {
    running "checking brew tap $1"
    brew tap | grep $1
    if [[ $? != 0 ]]; then
        action "brew tap $1"
        brew tap $1
        if [[ $? != 0 ]]; then
            error "failed to add brew tap $1! aborting..."
            exit -1
        fi
    fi
    ok
}
function require_brew() {
    running "which $1"
    which $1 > /dev/null 2>&1 | true
    if [[ ${PIPESTATUS[0]} != 0 ]]; then
        action "brew install $1 $2"
        brew install $1 $2
        if [[ $? != 0 ]]; then
            error "failed to install $1! aborting..."
            exit -1
        fi
    fi
    ok
}


function install_homebrew() {
    running "checking homebrew"
    brew_bin=$(which brew) 2>&1 > /dev/null
    if [[ $? != 0 ]]; then
        action "installing homebrew"
        ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
        if [[ $? != 0 ]]; then
            error "unable to install homebrew, script $0 abort!"
            exit -1
        fi
    fi
    ok
}

function install_brewcask() {
    running "checking brew-cask"
    output=$(brew tap | grep cask)
    if [[ $? != 0 ]]; then
        action "installing brew-cask"
        require_brew caskroom/cask/brew-cask
    fi
    ok
}


function checkInstall() {
  running "checking install of $1"
  case "$1" in
    *)
        which $1
        ;;
  esac
  if [[ $? != 0 ]]; then
    warn "$1 is not installed";
    return 1;
  fi
  ok
  return 0;
}

###
# Docker helpers
###
function dockerStart(){

    running "starting rsync into $VM_NAME"
    startRsync
    ok

    APPURL=http://$(docker-machine ip $VM_NAME 2>/dev/null):$APP_PORT_EXTERNAL

    # instead of loading the VBox IP, we are routing localhost:$APP_PORT_EXTERNAL to VM
    # APPURL=http://localhost:$APP_PORT_EXTERNAL

    running "starting via 'docker-compose up'"
    docker-compose up &

    docker images | grep $APP_NAME_LOCAL > /dev/null 2>&1

    if [[ $? != 0 ]]; then
      # give it time to create and launch the image
      bot "giving docker-compose time to create the image..."
      sleep $VM_CREATE_TIME
    fi

    # load in browser
    bot "OK, the app is booting up, we need to wait just a bit before trying to load it..."
    for i in $(seq $APP_BOOT_TIME 1);do
      bot "$i...";
    sleep 1;
    done

    if [[ $1 != "background" ]]; then

      bot "Launching: $APPURL"
      bot "If the app doesn't work, you can debug it by running the following:\n\$(docker-machine env $VM_NAME > /dev/null);\ndocker exec -i -t \$(docker ps | grep $APP_NAME_LOCAL | awk '{print $1;}') bash"
      # open $APPURL:$APP_PORT_EXTERNAL
      open $APPURL

    fi
}

# setup port forwarding localhost:$APP_PORT_EXTERNAL -> VirtualBox
function ensurePort(){
  running "ensuring port forwarding: "$APP_NAME_LOCAL"_"$1
  VBoxManage showvminfo $VM_NAME | grep $APP_NAME_LOCAL"_"$1 > /dev/null 2>&1
  if [ $? != 0 ]; then
    bot "adding port forwarding for $APP_NAME_LOCAL to $1"
    VBoxManage controlvm $VM_NAME natpf1 $APP_NAME_LOCAL"_"$1,tcp,,$1,,$1
  fi
  ok
}

function dockerStop(){
  running "stopping rsync"
  stopRsync
  ok
  running "stopping docker containers"
  docker-compose stop > /dev/null 2>&1
  ok
}

function shellinit(){
    running "shellinit"
    #ensurePort 2376
    #export DOCKER_HOST=tcp://127.0.0.1:2376;
    eval "$(docker-machine env $VM_NAME)"
    ok
}

# ensure that docker is running and mapped properly to the VM
function ensureDocker() {

    running "ensuring $VM_NAME vm is running"

    docker-machine ls | grep $VM_NAME > /dev/null 2>&1
    if [[ $? != 0 ]]; then
      # vm doesn't exist
      docker-machine create -d virtualbox $VM_NAME
    fi
    docker-machine ls | grep $VM_NAME | grep Running > /dev/null 2>&1
    if [[ $? != 0 ]]; then
      bot "starting the vm"
      docker-machine start $VM_NAME
    fi
    ok

    shellinit
    set +e
    docker ps > /dev/null 2>&1;
    if [[ $? != 0 ]]; then
      defaultError
    else
     return 1;
    fi
}

function startRsync(){
  if [[ $RSYNC != true ]];then
    return 0
  fi
  # only do one
  stopRsync
  dir=$(pwd);
  docker-rsync -watch=true -src="$dir/$APP_LOC" -dst="/Users/$(whoami)/rsync$dir/$APP_LOC" $VM_NAME &
  if [[ $? != 0 ]]; then
    bot "Fixing URL path in $VM_NAME"
    if [[ "$(docker-machine ssh $VM_NAME 'cat /opt/tcemirror')" != "$RSYNC_URL" ]]; then
      docker-machine ssh $VM_NAME "echo '$RSYNC_URL' > /opt/tcemirror"
    fi
    bot "Trying docker-rsync again"
    docker-rsync -src="$dir/$APP_LOC" -dst="/Users/$(whoami)/rsync$dir/$APP_LOC" $VM_NAME &
    if [[ $? != 0 ]]; then
      warn "Something went wrong with loading rsync"
    else
      ok
    fi
  fi
}

function stopRsync(){
  if [[ $RSYNC != true ]];then
    return 0
  fi
  #Check if rsync is already running
  if [[ $(ps ax | grep rsync | grep $(pwd) | grep -v grep | awk '{print $1}') == "" ]]; then
    return 0;
  fi
  #Else kill any processes where rsync is running
  kill -9 `ps ax | grep rsync | grep $(pwd) | grep -v grep | awk '{print $1}'`
  #Returning 1 stops script
  return 1;
}

function ensureMount(){
    # create an rsync directory in my home directory
    # so we don't use up all the space on the virtual machine
    # root path
    # (/Users is already mounted as a share by VirtualBox)
    if [ ! -d "/Users/$(whoami)/rsync" ]; then
      mkdir -p /Users/$(whoami)/rsync
    fi
    # we will then use docker-rsync to rsync into this directory
}
# OS_VERSION=$(sw_vers -productVersion);
# OS_MAJOR=`echo $OS_VERSION | cut -d. -f1`
# OS_MINOR=`echo $OS_VERSION | cut -d. -f2`
# OS_PATCH=`echo $OS_VERSION | cut -d. -f3`
function defaultError()
{
    error "sorry, we have not yet figured out an automated solution to this problem. Please investigate and pull-request to https://github.com/atomantic/generator-dockerize"
    exit 1;
}

#Allows VM to connect to $DOCKER_REPO insecure registry
function insecureRegistry()
{
    ensureDocker
    REGISTRY=$DOCKER_REPO
    if [ -n $1 ]; then
      REGISTRY=$1
    fi
    echo "setting insecure registry: "$REGISTRY;
    docker-machine ssh $VM_NAME "grep 'insecure-registry $REGISTRY' /var/lib/boot2docker/profile" > /dev/null 2>&1
    if [[ $? != 0 ]]; then
      docker-machine ssh $VM_NAME "sudo sed -i \"s/EXTRA_ARGS='/EXTRA_ARGS='\n--insecure-registry $DOCKER_REPO/\" /var/lib/boot2docker/profile"
      docker-machine ssh $VM_NAME "sudo /etc/init.d/docker restart"
      sleep 1
      docker-machine restart $VM_NAME
    fi
    ok
}

case "$1" in
    clean)
        # purges the docker images relating to this app
        ensureDocker
        docker ps -a | grep $APP_NAME_LOCAL
        if [[ $? == 0 ]]; then
          docker rm -f $(docker ps -a | grep $APP_NAME_LOCAL | awk '{print $1;}')
        fi
        docker images | grep $APP_NAME_LOCAL > /dev/null 2>&1
        if [ $? == 0 ]; then
          docker rmi -f $APP_NAME_LOCAL
        fi
        ok
        ;;
    free)
        ensureDocker
        running "removing all stopped containers"
        docker rm $(docker ps -a -q) > /dev/null 2>&1
        ok
        running "removing all untagged images (cruft)"
        docker rmi $(docker images -q --filter "dangling=true") > /dev/null 2>&1
        ok
        ;;
    init)
        bot "Hi, I'm going to setup/update your environment and startup the app using Docker"

        bot "working on "$APP_ORG/$APP_NAME:$APP_PORT_EXTERNAL;

        need_tools=0
        install_homebrew
        require_tap synack/docker
        if [[ $RSYNC == true ]];then
          require_brew docker-rsync
        fi

        needed_software=( "docker" "docker-compose" "docker-machine" "vboxmanage" )
        for sft in "${needed_software[@]}"; do
          checkInstall $sft
          if [ $? != 0 ]; then
            need_tools=1
          fi
        done

        if [ $need_tools == 1 ]; then
          install_brewcask
          require_cask dockertoolbox
          ok
        fi

        # setup docker-compose.yml
        me=$(whoami)
        dir=$(pwd)
        if [[ -a docker-compose.tmpl ]]; then
          cat docker-compose.tmpl | sed "s~_SYNCDIR_~/Users/$me/rsync$dir/$APP_LOC~" > docker-compose.yml
        fi
        # run dev.init instructions (install base npm modules, etc)
        source ./dev.init.sh

        ensureMount

        echo "launching quickstart shell. once this is done"
        echo "cd "$(pwd)
        echo "./dev start"

        bash --login '/Applications/Docker/Docker Quickstart Terminal.app/Contents/Resources/Scripts/start.sh'
        ;;
    insecure_registry)
        insecureRegistry $2
        ;;
    purge)
        bot "Starting Purge. ensuring rsync isn't running..."
        stopRsync
        ok
        bot "dockerized-vm machine"
        read -r -p "Shall I destroy this machine (with all docker images/containers in it)? [Y|n]" response
        if [[ $response =~ ^(no|n|N) ]];then
          bot "skipping..."
        else
          action "destroying the dockerized-vm machine"
          docker-machine kill $VM_NAME;
          docker-machine rm $VM_NAME;
          ok
        fi
        bot "VirtualBox Software"
        read -r -p "Uninstall VirtualBox? [y|N]" response
        if [[ $response =~ ^(y|Y|yes) ]];then
          action "killing virtualbox"
          pkill VBoxXPCOMIPCD
          pkill VBoxSVC
          pkill VBoxNetDHCP
          pkill VBoxHeadless
          ok
          bot "uninstall virtualbox"
          brew cask uninstall virtualbox
          ok
        else
          bot "skipping..."
        fi
        bot "Docker Software"
        read -r -p "Uninstall Docker Components? [y|N]" response
        if [[ $response =~ ^(y|Y|yes) ]];then
          action "uninstalling docker, docker-machine and docker-compose"
          brew uninstall docker docker-machine docker-compose
          ok
        else
          bot "skipping..."
        fi
        bot "run 'dev init' again"
        ;;
    rebuild)
        dockerStop
        docker-compose build
        dockerStart $1
        ;;
    restart)
        ensureDocker
        dockerStop
        dockerStart $1
        ;;
    shell)
        ensureDocker
        if [ -z $1 ]; then
          # run any version deployed to docker hub
          bot "checking $REMOTE_NAME for version tag $2"
          docker run --rm=true -t $REMOTE_NAME:$2
          docker exec -i -t $(docker ps | grep $REMOTE_NAME:$2 | awk '{print $1;}') bash
          exit $?;
        fi
        instance=$(docker ps | grep $APP_NAME_LOCAL | awk '{print $1;}')
        if [ -z "$instance" ]; then
          docker run --rm=true -i -t $APP_NAME_LOCAL bash
        else
          docker exec -i -t $instance bash
        fi
        ;;
    start)
        ensureDocker
        dockerStart $1
        ;;
    stop)
        ensureDocker
        dockerStop
        ;;
    test)
        ensureDocker
        build_scripts/test.sh 0.1.0 $APP_NAME_LOCAL $APP_PORT_EXTERNAL $APP_PORT_INTERNAL $VM_NAME
        ok "done"
        ;;
    update)
        bot "updating the dev toolkit"
        curl -o dev.latest https://raw.githubusercontent.com/atomantic/generator-dockerize/master/app/templates/dev
        ok "fetched latest"
        oldversion=$(grep "^# DockerDev:" dev | sed 's/[^0-9.]//g');
        newversion=$(grep "^# DockerDev:" dev.latest | sed 's/[^0-9.]//g');

        if [ "$oldversion" != "$newversion" ]; then
          bot "Update found! old: $oldversion -> new: $newversion"
          cp dev.latest dev
        fi
        rm dev.latest
        ok "you have the latest version: $newversion"
        ;;
    *)
        bot "Hi, I can do a few helpful development tricks.\n"
        echo -e "Run each as an argument to this script (e.g. './dev init'):\n"
        echo "clean - remove locally built docker containers and images relating to this app"
        echo "free - remove clutter (stopped containers and untagged images)"
        echo "init - initialize your development environment (installing and running the app)"
        echo "insecure_registry - sets up Docker to connect to an insecure registry"
        echo "purge - uninstall virtualbox, destroy the dockerized-vm machine and uninstall all docker software"
        echo "rebuild - rebuild the service"
        echo "restart - restart the service"
        echo "shell {version} - get a bash shell on the current running system or on a version from the hub"
        echo "start - start the service"
        echo "stop - stop the service"
        echo "test - test the service by running a docker image and pointing tests at the image"
        echo "tool - choose between docker-machine or vagrant"
        echo "update - update the dev tool with the latest automation scripts"
        ;;
esac
