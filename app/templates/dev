#!/usr/bin/env bash

###########################################
# This is the project's developer toolkit #
# It was generated by                     #
# generator-dockerize                     #
#
# if you find an issue with this script
# make a pull-request on
# https://github.com/atomantic/generator-dockerize
#
# @author Adam Eivy                       #
# DockerDev: 1.6.4                        #
###########################################

# project specific config
source ./dev.config

# docker-compose will strip underscores from the app name to tack on _web
APP_NAME_LOCAL=${APP_NAME//_/}"_web"
REMOTE_NAME="$DOCKER_REPO/$APP_ORG/$APP_NAME"
RSYNC_URL="http://distro.ibiblio.org/tinycorelinux"

###
# echo helper functions
###
# Colors
ESC_SEQ="\x1b["
COL_RESET=$ESC_SEQ"39;49;00m"
COL_RED=$ESC_SEQ"31;01m"
COL_GREEN=$ESC_SEQ"32;01m"
COL_YELLOW=$ESC_SEQ"33;01m"
COL_BLUE=$ESC_SEQ"34;01m"
COL_MAGENTA=$ESC_SEQ"35;01m"
COL_CYAN=$ESC_SEQ"36;01m"

function ok() {
    echo -e "$COL_GREEN[ok]$COL_RESET "$1
}

function bot() {
    echo
    echo -e "$COL_GREEN\[._.]/$COL_RESET - "$1
}

function running() {
    echo
    echo -en " ⇒ "$1"..."
}

function action() {
    echo -e "$COL_YELLOW[action]$COL_RESET"
    echo -en " ⇒ "$1"..."
}

function warn() {
    echo -e "$COL_YELLOW[warning]$COL_RESET "$1
}

function error() {
    echo -e "$COL_RED[error]$COL_RESET "$1
}

###
# some bash install helpers
###
function require_cask() {
    running "which $1"
    which $1 > /dev/null 2>&1 | true
    if [[ ${PIPESTATUS[0]} != 0 ]]; then
        brew cask list $1 > /dev/null 2>&1 | true
        if [[ ${PIPESTATUS[0]} != 0 ]]; then
            action "brew cask install $1 $2"
            brew cask install $1
            if [[ $? != 0 ]]; then
                error "failed to install $1! aborting..."
                exit -1
            fi
        fi
    fi
    ok
}

function require_tap() {
    running "checking brew tap $1"
    brew tap | grep $1
    if [[ $? != 0 ]]; then
        action "brew tap $1"
        brew tap $1
        if [[ $? != 0 ]]; then
            error "failed to add brew tap $1! aborting..."
            exit -1
        fi
    fi
    ok
}
function require_brew() {
    running "which $1"
    which $1 > /dev/null 2>&1 | true
    if [[ ${PIPESTATUS[0]} != 0 ]]; then
        action "brew install $1 $2"
        brew install $1 $2
        if [[ $? != 0 ]]; then
            error "failed to install $1! aborting..."
            exit -1
        fi
    fi
    ok
}


function install_homebrew() {
    running "checking homebrew"
    brew_bin=$(which brew) 2>&1 > /dev/null
    if [[ $? != 0 ]]; then
        action "installing homebrew"
        ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
        if [[ $? != 0 ]]; then
            error "unable to install homebrew, script $0 abort!"
            exit -1
        fi
    fi
    ok
}

function install_brewcask() {
    running "checking brew-cask"
    output=$(brew tap | grep cask)
    if [[ $? != 0 ]]; then
        action "installing brew-cask"
        require_brew caskroom/cask/brew-cask
    fi
    ok
}


function checkInstall() {
  running "checking install of $1"
  case "$1" in
    *)
        which $1
        ;;
  esac
  if [[ $? != 0 ]]; then
    warn "$1 is not installed";
    return 1;
  fi
  ok
  return 0;
}

###
# Docker helpers
###
function dockerStart(){

    # still working on VPN fix
    #ensurePort $APP_PORT_EXTERNAL
    running "starting rsync into $VM_NAME"
    startRsync
    ok

    APPURL=http://$(docker-machine ip $VM_NAME 2>/dev/null):$APP_PORT_EXTERNAL
    # instead of loading the VBox IP, we are routing localhost:$APP_PORT_EXTERNAL to VM
    # APPURL=http://localhost:$APP_PORT_EXTERNAL

    running "starting via 'docker-compose up'"
    docker-compose up &

    docker images | grep $APP_NAME_LOCAL > /dev/null 2>&1

    if [[ $? != 0 ]]; then
      # give it time to create and launch the image
      bot "giving docker-compose time to create the image..."
      sleep $VM_CREATE_TIME
    fi

    # load in browser
    bot "OK, the app is booting up, we need to wait just a bit before trying to load it..."
    for i in $(seq $APP_BOOT_TIME 1);do
      bot "$i...";
    sleep 1;
    done

    if [[ $1 != "background" ]]; then

      bot "Launching: $APPURL"
      bot "If the app doesn't work, you can debug it by running the following:\n\$(docker-machine env $VM_NAME > /dev/null);\ndocker exec -i -t \$(docker ps | grep $APP_NAME_LOCAL | awk '{print $1;}') bash"
      # open $APPURL:$APP_PORT_EXTERNAL
      open $APPURL

    fi
}

# setup port forwarding localhost:$APP_PORT_EXTERNAL -> VirtualBox
function ensurePort(){
  running "ensuring port forwarding: "$APP_NAME_LOCAL"_"$1
  VBoxManage showvminfo $VM_NAME | grep $APP_NAME_LOCAL"_"$1 > /dev/null 2>&1
  if [ $? != 0 ]; then
    bot "adding port forwarding for $APP_NAME_LOCAL to $1"
    VBoxManage controlvm $VM_NAME natpf1 $APP_NAME_LOCAL"_"$1,tcp,,$1,,$1
  fi
  ok
}

function dockerStop(){
  running "stopping rsync"
  stopRsync
  ok
  running "stopping docker containers"
  docker-compose stop > /dev/null 2>&1
  ok
}

function shellinit(){
    running "shellinit"
    # make sure docker port routing is in place (need this if we are on cisco vpn on yosemite)
    # https://github.com/boot2docker/boot2docker/issues/392#issuecomment-66694197
    # still working on VPN fix... this isn't working with docker-machine
    # maybe a fix in here somewhere: https://github.com/docker/machine/issues/1031
    #ensurePort 2376
    #export DOCKER_HOST=tcp://127.0.0.1:2376;
    eval "$(docker-machine env $VM_NAME)"
    ok
}

# ensure that docker is running and mapped properly to the VM
function ensureDocker() {

    running "ensuring $VM_NAME vm is running"

    docker-machine ls | grep $VM_NAME > /dev/null 2>&1
    if [[ $? != 0 ]]; then
      # vm doesn't exist
      action "$VM_NAME vm does not exist. Creating it"

      docker-machine create -d virtualbox $VM_NAME
    fi
    docker-machine ls | grep $VM_NAME | grep Running > /dev/null 2>&1
    if [[ $? != 0 ]]; then
      bot "starting the vm"
      docker-machine start $VM_NAME
    fi
    ok

    shellinit

    docker ps > /dev/null 2>&1;
    if [[ $? != 0 ]]; then
      defaultError
    else
      return 1;
    fi
}

function startRsync(){
  # only do one
  stopRsync
  dir=$(pwd);
  docker-rsync -src="$dir/$APP_LOC" -dst="/Users/$(whoami)/rsync$dir/$APP_LOC" $VM_NAME &
  if [[ $? != 0 ]]; then
    bot "Fixing URL path in $VM_NAME"
    if [[ "$(docker-machine ssh $VM_NAME 'cat /opt/tcemirror')" != "$RSYNC_URL" ]]; then
      docker-machine ssh $VM_NAME "echo '$RSYNC_URL' > /opt/tcemirror"
    fi
    bot "Trying docker-rsync again"
    docker-rsync -src="$dir/$APP_LOC" -dst="/Users/$(whoami)/rsync$dir/$APP_LOC" $VM_NAME &
    if [[ $? != 0 ]]; then
      warn "Something went wrong with loading rsync"
    else
      ok
    fi
  fi
}

function stopRsync(){
  ps ax | grep rsync | grep $(pwd) | grep -v grep
  if [ $? != 0 ]; then
    return 0;
  fi
  kill -9 `ps ax | grep rsync | grep $(pwd) | grep -v grep | awk '{print $1}'`
  return 1;
}

function ensureMount(){
    # create an rsync directory in my home directory
    # so we don't use up all the space on the virtual machine
    # root path
    # (/Users is already mounted as a share by VirtualBox)
    if [ ! -d "/Users/$(whoami)/rsync" ]; then
      mkdir -p /Users/$(whoami)/rsync
    fi
    # we will then use docker-rsync to rsync into this directory
}

# OS_VERSION=$(sw_vers -productVersion);
# OS_MAJOR=`echo $OS_VERSION | cut -d. -f1`
# OS_MINOR=`echo $OS_VERSION | cut -d. -f2`
# OS_PATCH=`echo $OS_VERSION | cut -d. -f3`
function defaultError()
{
    error "sorry, we have not yet figured out an automated solution to this problem. Please investigate and pull-request to https://github.com/atomantic/generator-dockerize"
    exit 1;
}

case "$1" in
    clean)
        # purges the docker images relating to this app
        shellinit
        docker ps -a | grep $APP_NAME_LOCAL
        if [[ $? == 0 ]]; then
          docker rm -f $(docker ps -a | grep $APP_NAME_LOCAL | awk '{print $1;}')
        fi
        docker images | grep $APP_NAME_LOCAL > /dev/null 2>&1
        if [ $? == 0 ]; then
          docker rmi -f $APP_NAME_LOCAL
        fi
        ok
        ;;
    free)
        ensureDocker
        running "removing all stopped containers"
        docker rm $(docker ps -a -q) > /dev/null 2>&1
        ok
        running "removing all untagged images (cruft)"
        docker rmi $(docker images -q --filter "dangling=true") > /dev/null 2>&1
        ok
        ;;
    init)
        bot "Hi, I'm going to setup/update your environment and startup the app."

        bot "working on "$APP_ORG/$APP_NAME:$APP_PORT_EXTERNAL;

        install_homebrew
        require_tap synack/docker
        require_brew docker-rsync
        need_tools=0

        needed_software=( "docker" "docker-compose" "docker-machine" "vboxmanage" )
        for sft in "${needed_software[@]}"; do
          checkInstall $sft
          if [ $? != 0 ]; then
            need_tools=1
          fi
        done

        if [ $need_tools == 1 ]; then
          bot "You can either install the base set of tools with Docker Toolbox: https://www.docker.com/toolbox\nOr install via homebrew."
          read -r -p "Use Homebrew? [Y|n]" response
          if [[ ! $response =~ ^(no|n|N) ]];then
              install_brewcask
              require_brew docker
              require_brew docker-compose
              require_brew docker-machine
              require_cask virtualbox
              ok
          else
            read -r -p "Did you install Docker Toolkit? [Y|n]" responseToolbox
            if [[ $responseToolbox =~ ^(no|n|N) ]];then
              bot "well, go install Docker Toolkit, then run 'dev init' again"
              exit 1
            fi
            ok
          fi
        fi

        # setup docker-compose.yml
        me=$(whoami)
        dir=$(pwd)
        cat docker-compose.tmpl | sed "s~_SYNCDIR_~/Users/$me/rsync$dir/$APP_LOC~" > docker-compose.yml

        # run dev.init instructions (install base npm modules, etc)
        source ./dev.init.sh

        ensureMount

        ensureDocker

        dockerStart
        ;;
    purge)
        stopRsync
        shellinit
        bot "destroying the dockerized-vm machine"
        docker-machine kill $VM_NAME;
        docker-machine rm $VM_NAME;
        ok
        bot "killing virtualbox"
        pkill VBoxXPCOMIPCD
        pkill VBoxSVC
        pkill VBoxNetDHCP
        pkill VBoxHeadless
        ok
        bot "uninstall virtualbox"
        brew cask uninstall virtualbox
        ok
        bot "uninstall docker components"
        brew uninstall docker docker-machine docker-compose
        ok
        bot "run 'dev init' again"
        ;;
    restart)
        ensureDocker
        dockerStop
        dockerStart $1
        ;;
    shell)
        ensureDocker
        if [ -z $1 ]; then
          # run any version deployed to docker hub
          bot "checking $REMOTE_NAME for version tag $2"
          docker run -t $REMOTE_NAME:$2
          docker exec -i -t $(docker ps | grep $REMOTE_NAME:$2 | awk '{print $1;}') bash
          exit $?;
        fi
        instance=$(docker ps | grep $APP_NAME_LOCAL | awk '{print $1;}')
        if [ -z "$instance" ]; then
          docker run -i -t $APP_NAME_LOCAL bash
        else
          docker exec -i -t $instance bash
        fi
        ;;
    start)
        ensureDocker
        dockerStart $1
        ;;
    stop)
        ensureDocker
        dockerStop
        ;;
    test)
        ensureDocker
        test.sh 0.1.0 $APP_NAME_LOCAL $APP_PORT_EXTERNAL $APP_PORT_INTERNAL $VM_NAME
        ok "done"
        ;;
    update)
        bot "updating the dev toolkit"
        curl -o dev.latest https://raw.githubusercontent.com/atomantic/generator-dockerize/master/app/templates/dev
        ok "fetched latest"
        oldversion=$(grep "^# DockerDev:" dev | sed 's/[^0-9.]//g');
        newversion=$(grep "^# DockerDev:" dev.latest | sed 's/[^0-9.]//g');

        if [ "$oldversion" != "$newversion" ]; then
          bot "Update found! old: $oldversion -> new: $newversion"
          cp dev.latest dev
        fi
        rm dev.latest
        ok "you have the latest version: $newversion"
        ;;
    vpn)
        bot "Fixing route table after Cisco VPN disconnect"
        read -r -p "Did you disconnect VPN? [Y|n]" response
        if [[ $response =~ ^(no|n|N) ]];then
          bot "well do that and re-run this..."
          exit 2;
        fi
        ok
        VBOXNET=$(VBoxManage showvminfo $VM_NAME --machinereadable | grep hostonlyadapter | cut -d '"' -f 2)

        if [ -z "$VBOXNET" ]; then
          error "No vboxnet interface found for VM $VM_NAME"
          exit -1;
        fi
        ip_address=$(docker-machine ip $VM_NAME)
        ip_sub=$(echo $ip_address | sed 's/.[^\.]*$//g')
        bot "Requires sudo:"
        sudo route -n delete -net $ip_sub
        sudo route -n add -net $ip_sub.0/24 -interface $VBOXNET
        ok
        ;;
    *)
        bot "Hi, I can do a few helpful development tricks.\n"
        echo -e "Run each as an argument to this script (e.g. './dev init'):\n"
        echo "clean - remove locally built docker containers and images relating to this app"
        echo "free - remove clutter (stopped containers and untagged images)"
        echo "init - initialize your development environment (installing and running the app)"
        echo "purge - uninstall virtualbox, destroy the dockerized-vm machine and uninstall all docker software"
        echo "restart - restart the service"
        echo "shell {version} - get a bash shell on the current running system or on a version from the hub"
        echo "start - start the service"
        echo "stop - stop the service"
        echo "test - test the service by running a docker image and pointing tests at the image"
        echo "update - update the dev tool with the latest automation scripts"
        echo "vpn - fix routing table after disconnecting from Cisco Anyconnect VPN client"
        ;;
esac
